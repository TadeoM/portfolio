<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Web Audio Visualizer</title>
	<link rel="stylesheet" href="stylesheet.css">
	<script>
	// An IIFE ("Iffy") - see the notes in mycourses
	(function(){
		"use strict";
		
		let NUM_SAMPLES = 256;
		let SOUND_1 = 'media/Great Fairy\'s Fountain.mp3';
		let SOUND_2 = 'media/Final Hours.mp3';
		let SOUND_3 = 'media/Goodbye To A World.mp3';
		let audioElement;
		let analyserNode;
		let canvas,ctx;
		let invert = false, tint = false, noise = false, effect = true, brightness, distort = false;
		let tintColor = 'red', backgroundColor = 'black';
		let circlePos = [];
		let circleMinRadius, circleMaxRadius;
		let barMinHeight, barMaxHeight;
		let mainBarMaxHeight, mainBarStartHeight;
		let lastData = [], lastDataMax;
		let minCurveHighHeight, maxCurveHighHeight, minCurveLowHeight, maxCurveLowHeight;
		let delayAmount = 0;
		let delayNode;
		let bassFilter, trebleFilter;
		let waveGradient;
		let trailBlur;
		let trailBlurTracker=[];
		let useWave = false;

		function init(){
			// set up canvas stuff
			canvas = document.querySelector('canvas');
			ctx = canvas.getContext("2d");
			
			// get reference to <audio> element on page
			audioElement = document.querySelector('audio');
			
			// call our helper function and get an analyser node
			analyserNode = createWebAudioContextWithAnalyserNode(audioElement);
			
			// get sound track <select> and Full Screen button working
			setupUI();
			
			// load and play default sound into audio element
			playStream(audioElement,SOUND_1);

			setup();

			brightness = 0;
			barMinHeight = 4;
			barMaxHeight = 70;

			mainBarMaxHeight = 200;

			minCurveHighHeight = 2;
			maxCurveHighHeight = 400;
			minCurveLowHeight = 2;
			maxCurveLowHeight = 1000;

			lastDataMax = 3;
			trailBlur = 4;

			window.onresize = setup;
			waveGradient = getWaveGradient();

			setupCircles();

			// start animation loop
			update();
		}

		//setup screen dependant elements
		function setup()
		{
			canvas.height = window.innerHeight;
			canvas.width = window.innerWidth;

			circleMinRadius = canvas.width / 400;
			circleMaxRadius = canvas.width / 100;
			mainBarStartHeight = canvas.height / 2;

			waveGradient = getWaveGradient();
		}
		
		//helper function to get a random number
		function getRandomNum(min, max)
		{
			return Math.floor((Math.random() * (max - min)) + min);
		}

		//setup initial circle positions
		function setupCircles()
		{
			for (let i = 0; i < NUM_SAMPLES; i++)
			{
				let position = {x: 0, y: 0};

				position.x = getRandomNum(circleMaxRadius, canvas.width - circleMaxRadius);
				position.y = getRandomNum(circleMaxRadius, canvas.height - circleMaxRadius);

				circlePos.push(position);
			}
		}
		
		//setup the web audio analyser nodes
		function createWebAudioContextWithAnalyserNode(audioElement) {
			let audioCtx, analyserNode, sourceNode;
			// create new AudioContext
			// The || is because WebAudio has not been standardized across browsers yet
			// http://webaudio.github.io/web-audio-api/#the-audiocontext-interface
			audioCtx = new (window.AudioContext || window.webkitAudioContext);
			
			//delay node
			delayNode = audioCtx.createDelay();
			delayNode.delayTime.value = delayAmount;
			
			//bass and treble filter
			bassFilter = audioCtx.createBiquadFilter();
			trebleFilter = audioCtx.createBiquadFilter();

			// create an analyser node
			analyserNode = audioCtx.createAnalyser();
			
			// fft stands for Fast Fourier Transform
			analyserNode.fftSize = NUM_SAMPLES;
			
			// this is where we hook up the <audio> element to the analyserNode
			sourceNode = audioCtx.createMediaElementSource(audioElement); 
			
			//connect everything
			sourceNode.connect(audioCtx.destination);
			sourceNode.connect(delayNode);
			delayNode.connect(bassFilter);
			bassFilter.connect(trebleFilter);
			trebleFilter.connect(analyserNode);
			analyserNode.connect(audioCtx.destination);

			//setup bass and treble filters
            bassFilter.type = "lowshelf";
            bassFilter.frequency.value = 400;
            bassFilter.gain.value = 0;

			trebleFilter.type = "highshelf";
			trebleFilter.frequency.type = 2000;
			trebleFilter.gain.value = 0;


			// here we connect to the destination i.e. speakers
			analyserNode.connect(audioCtx.destination);
			return analyserNode;
		}
		
		//setup all UI elements
		function setupUI(){
			document.querySelector("#trackSelect").onchange = function(e){
				playStream(audioElement,e.target.value);
			};
			
			document.querySelector("#fsButton").onclick = function(){
				requestFullscreen(canvas);
			};

			document.querySelector('#invert').onchange = function(){
				invert = !invert;
			}
			document.querySelector('#tint').onchange = function()
			{
				tint = !tint;
			}
			document.querySelector('#noise').onchange = function()
			{
				noise = !noise;
			}
			document.querySelector('#distort').onchange = function()
			{
				distort = !distort;
			}
			document.querySelector('#dataTypeSelect').onchange = function(e)
			{
				if (e.target.value == "freq")
				{
					useWave = false;
				}
				else
				{
					useWave = true;
				}
			}
			document.querySelector("#brightnessSlider").oninput = function(e){
				brightness = Math.floor(e.target.value);
				document.querySelector('#brightnessCounter').innerHTML = "Brightness: " + brightness;
			};
			document.querySelector('#trailAmountSlider').oninput = function(e)
			{
				//get new trail amount value and reset the variable so that it gets rid of excess values
				lastDataMax = Math.floor(e.target.value);
				document.querySelector('#trailAmountCounter').innerHTML = "Wave Trail Amount: " + lastDataMax;
				do{
					lastData.splice(0, 1);
				}while(lastData.length > lastDataMax);
			};
			document.querySelector('#trailBlurSlider').oninput = function(e)
			{
				trailBlur = Math.floor(e.target.value);
				document.querySelector('#trailBlurCounter').innerHTML = "Wave Trail Blur Amount: " + trailBlur;
			};
			document.querySelector('#delayAmountSlider').oninput = function(e)
			{
				delayNode.delayTime.value = e.target.value;
				document.querySelector('#delayAmountCounter').innerHTML = "Delay: " + delayNode.delayTime.value + "s";
			};
			document.querySelector('#circleModSlider').oninput = function(e)
			{
				circleMaxRadius = (canvas.width/100) + Math.abs(e.target.value);
				document.querySelector('#circleModText').innerHTML = "Max Circle Radius Modifier: +" + e.target.value;
			};
			document.querySelector('#waveMaxSlider').oninput = function(e)
			{
				mainBarMaxHeight = Math.floor(e.target.value);
				document.querySelector('#waveMaxText').innerHTML = "Wave Max Height: " + mainBarMaxHeight;
			};
			document.querySelector('#barMinSlider').oninput = function(e)
			{
				barMinHeight = Math.floor(e.target.value);
				document.querySelector('#barMinText').innerHTML = "Bar Min Height: " + barMinHeight;
			};
			document.querySelector('#barMaxSlider').oninput = function(e)
			{
				barMaxHeight = Math.floor(e.target.value);
				document.querySelector('#barMaxText').innerHTML = "Bar Max Height: " + barMaxHeight;
			};
			document.querySelector('#curveLowMinSlider').oninput = function(e)
			{
				minCurveLowHeight = Math.floor(e.target.value);
				document.querySelector('#curveLowMinText').innerHTML = "Low Freq Curve Min Height: " + minCurveLowHeight;
			};
			document.querySelector('#curveLowMaxSlider').oninput = function(e)
			{
				maxCurveLowHeight = Math.floor(e.target.value);
				document.querySelector('#curveLowMaxText').innerHTML = "Low Freq Curve Max Height: " + maxCurveLowHeight;
			};
			document.querySelector('#curveHighMinSlider').oninput = function(e)
			{
				minCurveHighHeight = Math.floor(e.target.value);
				document.querySelector('#curveHighMinText').innerHTML = "High Freq Curve Min Height: " + minCurveHighHeight;
			};
			document.querySelector('#curveHighMaxSlider').oninput = function(e)
			{
				maxCurveHighHeight = Math.floor(e.target.value);
				document.querySelector('#curveHighMaxText').innerHTML = "High Freq Curve Max Height: " + maxCurveHighHeight;
			};
			document.querySelector('#volumeSlider').oninput = function(e)
			{
				audioElement.volume = (e.target.value / 100);
				document.querySelector('#volumeCounter').innerHTML = e.target.value + "%";
			};
			document.querySelector('#bassFilterSlider').oninput = function(e)
			{
				bassFilter.gain.value = e.target.value;
				document.querySelector('#bassFilterCounter').innerHTML = "Bass Boost: "+e.target.value;				
			}
			document.querySelector('#trebleFilterSlider').oninput = function(e)
			{
				trebleFilter.gain.value = e.target.value;
				document.querySelector('#trebleFilterCounter').innerHTML = "Treble Boost: "+e.target.value;								
			}
			document.querySelector('#tintSelect').onchange = function(e)
			{
				tintColor = e.target.value;
			}
			document.querySelector('#backgroundSelect').onchange = function(e)
			{
				backgroundColor = e.target.value;
			}
		}
		
		//play the current audio stream
		function playStream(audioElement,path){
			audioElement.src = path;
			audioElement.play();
			audioElement.volume = 0.05;
		}
		
		//main update function
		function update() { 

			// this schedules a call to the update() method in 1/60 seconds
			requestAnimationFrame(update);
			/*
				Nyquist Theorem
				http://whatis.techtarget.com/definition/Nyquist-Theorem
				The array of data we get back is 1/2 the size of the sample rate 
			*/
			
			// create a new array of 8-bit integers (0-255)
			let data = new Uint8Array(NUM_SAMPLES/2); 
			// populate the array with the frequency data
			// notice these arrays can be passed "by reference" 

			//decide whether to use waveform or frequency data
			if (!useWave)
			{
				analyserNode.getByteFrequencyData(data);
			}
			else
			{
				analyserNode.getByteTimeDomainData(data);
			}
			
			//clear everything
			ctx.clearRect(0,0,canvas.width,canvas.height);  

			//fill background
			ctx.fillStyle = backgroundColor;
			ctx.fillRect(0,0,canvas.width,canvas.height);

			//setup variables for spacing and width of bars
			let barWidth = 2.6;
			let lineSpacing = 2.085;
			let mainBarWidth = 2;
			let screenScale = canvas.width / 1423;
			let mainBarSpacing = 5.56 * screenScale;

			let highestFreq = 0;
			let averageBeatHigh = 0, averageBeatLow = 0;

			//draw circles first
			for (let i=0; i<data.length; i++)
			{
				updateCircle(i, data[i]);
				
				//find the highest freq, along with the averge beat for high and low freq
				if (data[i] != 0)
				{
					highestFreq = i;
				}
				if (i < data.length/4)
				{
					averageBeatHigh+=data[i];
				}
				else
				{
					averageBeatLow+=data[i];
				}
			}
			//setup averages and highest freq
			averageBeatHigh /= data.length/4;
			averageBeatLow /= (data.length/4) * 3;
			highestFreq = data.length - highestFreq;

			//draw the trails
			//this will go through 'lastData' which is a array of previous freq data and draw it to the screen
			ctx.save();			
			for (let i = 0; i < lastData.length; i++)
			{
				let curData = lastData[i];
				ctx.globalAlpha = 0.5 - (0.3 * (i/lastData.length)); //set alpha based on trail depth				
				for (let j = 0; j < lastData[i].length; j++)
				{
					if (j >= highestFreq - 2)
					{
						//trail blur effect will skip nodes based on user input
						//it also draws lines to fill in skipped nodes
						if (j%trailBlur == 0 || (j >= highestFreq-2 && j <= highestFreq+(trailBlur-2)) || (j < lastData[i].length && j >= lastData[i].length - trailBlur))
						{

							let xPos = (mainBarSpacing * j);
							let xPosNext = (mainBarSpacing * (j + 1));

							//draw trail connecting lines
							if (trailBlur > 1 && trailBlurTracker.length > 1)
							{
								if (!(j - trailBlur < highestFreq))
								{
									drawWave(trailBlurTracker[0].x, trailBlurTracker[0].y, trailBlurTracker[0].data, xPos, mainBarStartHeight, curData[curData.length - j], mainBarWidth, false);
									drawWave(trailBlurTracker[1].x, trailBlurTracker[1].y, trailBlurTracker[1].data, canvas.width - xPos, mainBarStartHeight, curData[curData.length - j], mainBarWidth, false);
								}
								trailBlurTracker = [];
							}
							
							let track = true;
							if (trailBlur == 1)
							{
								track = false;
							}
							//draw trail
							drawWave(xPos, mainBarStartHeight, curData[curData.length - j], xPosNext, mainBarStartHeight, curData[curData.length - (j + 1)], mainBarWidth, track);
							drawWave(canvas.width - xPos, mainBarStartHeight, curData[curData.length-j], canvas.width - xPosNext, mainBarStartHeight, curData[curData.length - (j + 1)], mainBarWidth, track);
						}
					}
				}
			}
			ctx.restore();

			// loop through the data and draw!
			for(let i=0; i<data.length; i++) 
			{ 
				//draw lines for bar visualizers (the ones in each corner)
				let xPos = barWidth + (lineSpacing * i) + (barWidth * i);
				drawLine(xPos, canvas.height, barWidth, data[i], false);
				drawLine(canvas.width - xPos, canvas.height, barWidth, data[i], false);
				drawLine(xPos, 0, barWidth, data[i], true);
				drawLine(canvas.width - xPos, 0, barWidth, data[i], true);
				
				//draw the main 'wave' visualizer
				if (i >= highestFreq - 2)
				{
					xPos = (mainBarSpacing * i);
					let xPosNext = (mainBarSpacing * (i + 1));
					drawWave(xPos, mainBarStartHeight, data[data.length - i], xPosNext, mainBarStartHeight, data[data.length - (i + 1)], mainBarWidth, false);
					drawWave(canvas.width - xPos, mainBarStartHeight, data[data.length-i], canvas.width - xPosNext, mainBarStartHeight, data[data.length - (i + 1)], mainBarWidth, false);
				}
			}
			
			//keep track of new data for trail, get rid of old data
			lastData.push(data);

			if (lastData.length > lastDataMax)
			{
				lastData.splice(0, 1);
			}

			//setup variables for curves
			let xPos = (mainBarSpacing * highestFreq);
			let cpYLow = (averageBeatLow/255) * (maxCurveLowHeight - minCurveLowHeight) + minCurveLowHeight;
			let cpYHigh = (averageBeatHigh/255) * (maxCurveHighHeight - minCurveHighHeight) + minCurveHighHeight;

			//draw curves
			//top curves (high freq)
			drawArc(0, canvas.height/2, xPos - 10, canvas.height/2, xPos/2, canvas.height/2 - cpYHigh, 2);
			drawArc(canvas.width - xPos + 10, canvas.height/2, canvas.width, canvas.height/2, canvas.width - (xPos/2), canvas.height/2 - cpYHigh, 2);
			//bottom curves (low freq)
			drawArc(xPos/4 - 10, canvas.height/2, -5 + (xPos/4) * 3, canvas.height/2, xPos/2, canvas.height/2 + cpYLow, 1);			
			drawArc(canvas.width - ((xPos/4) * 3) + 5, canvas.height/2, 10 + canvas.width - (xPos/4), canvas.height/2, canvas.width - (xPos/2), canvas.height/2 + cpYLow, 1);
			
			//draw post-effects
			manipulatePixels();
		} 

		//draw a curve for the sides of the center visualizer
		function drawArc(x1,y1,x2,y2,cpX,cpY,lineWidth=5)
		{
			ctx.save();
			ctx.strokeStyle = waveGradient;
			ctx.lineWidth = lineWidth;
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.quadraticCurveTo(cpX, cpY, x2, y2);
			ctx.closePath();
			ctx.stroke();
			ctx.restore();
		}

		//setup the wave gradient
		function getWaveGradient()
		{
			let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 5, canvas.width/2, canvas.height/2, canvas.width/2);
			grad.addColorStop(0, "#4286f4");
			grad.addColorStop(1/4, "#1a6df2");
			grad.addColorStop(2/4, "#025def");
			grad.addColorStop(3/4, "#1a6df2");
			grad.addColorStop(1, "#4286f4");
			
			return grad;
		}

		//draw the 'wave' for the main center visualizer
		function drawWave(x1, y1, data1, x2, y2, data2, width, tracking)
		{
			//offset based on data for current and next node
			let offSet1 = (data1/255) * mainBarMaxHeight;
			let offSet2 = (data2/255) * mainBarMaxHeight;

			ctx.save();

			ctx.strokeStyle = waveGradient;
			ctx.lineWidth = width;
			ctx.beginPath();
			ctx.moveTo(x1, y1 - offSet1);
			ctx.lineTo(x2, y2 - offSet2);
			ctx.moveTo(x1, y1 + offSet1);
			ctx.lineTo(x2, y2 + offSet2);
			ctx.closePath();
			ctx.stroke();

			ctx.restore();

			//tracking used for trail with blur effect
			if (tracking)
			{		
				let pos = {x: x2, y: y2, data: data2};
				trailBlurTracker.push(pos);			
			}
		}

		//draw a line for the bar visualizer
		function drawLine(x, y, width, data, flip)
		{
			ctx.save();

			ctx.strokeStyle = makeColor(100, 100, 100, 0.6);
			ctx.lineWidth = width;
			ctx.beginPath();
			ctx.moveTo(x, y);

			let size = ((data/255) * (barMaxHeight - barMinHeight) + barMinHeight);
			let yNew = (flip) ? y + size : y - size;
			ctx.lineTo(x, yNew);
			ctx.closePath();
			ctx.stroke();

			ctx.restore();
		}

		//updates circles positions and draws them
		function updateCircle(index, data)
		{
			let percent = data / 255;
			let radius = circleMinRadius + ((circleMaxRadius - circleMinRadius) * percent);
			let color = makeColor(100, 100, 100, (0.6 * percent) + 0.4);

			//update circle positions
			//once they reach the top, reset them to the bottom and assign a random x value
			circlePos[index].y -= 1;
			if (circlePos[index].y <= -circleMaxRadius)
			{
				circlePos[index].y = canvas.height + circleMaxRadius;
				circlePos[index].x = getRandomNum(circleMaxRadius, canvas.width - circleMaxRadius);
			}

			ctx.save();

			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(circlePos[index].x, circlePos[index].y, radius, 0, Math.PI * 2, false);	
			ctx.closePath();
			ctx.fill();
			ctx.restore();
		}
		
		//function to apply filters to the canvas
		function manipulatePixels()
		{
			let imageData = ctx.getImageData(0,0,canvas.width, canvas.height);
			let data = imageData.data;
			let length = data.length;
			let width = imageData.width;

			let rAdd=0, gAdd=0, bAdd=0;
			//set-up for tint, decreases lag to do it this way
			if (tint)
			{
				if (tintColor == 'red' || tintColor == 'purple' || tintColor == 'yellow')
					{
						rAdd = 100;
					}
					if (tintColor == 'green' || tintColor == 'yellow')
					{
						gAdd = 100;
					}
					if (tintColor == 'blue' || tintColor == 'purple')
					{
						bAdd = 100;
					}
			}

			for (let i = 0; i < length; i+= 4)
			{
				//apply a tint
				if (tint)
				{
					data[i] += rAdd;
					data[i+1] += gAdd;
					data[i+2] += bAdd;
				}
				//invert colors
				if (invert)
				{
					let red = data[i], green = data[i+1], blue = data[i + 2];
					data[i] = 255 - red;
					data[i+1] = 255 - green;
					data[i+2] = 255 - blue;
				}
				//noise
				if (noise && Math.random() < .001){
					data[i] = data[i + 1] = data[i + 2] = 128;

					data[i + 3] = 255;
				}
				//brightness effect
				if (effect)
				{
					let red = data[i], green = data[i+1], blue = data[i+2];

					red += brightness;
					if (red > 200)
					{
						red = 200;
					}
					blue += brightness;
					if (blue > 200)
					{
						blue =200;
					}
					green += brightness;
					if (green > 200)
					{
						green = 200;
					}

					data[i] = red;
					data[i+1] = green;
					data[i+2] = blue;
				}
				//distort effect - every 5 rows, pushes all pixles to the left 1
				if (distort)
				{	
					if ((i / (canvas.width*4)) % 5 < 1)
					{
						data[i] = data[i+4];
						data[i+1] = data[i+5];
						data[i+2] = data[i+6];
						data[i+3] -= 50;
					}
					
				}
			}

			ctx.putImageData(imageData, 0, 0);
		}

		// HELPER
		function makeColor(red, green, blue, alpha){
   			let color='rgba('+red+','+green+','+blue+', '+alpha+')';
   			return color;
		}
		
		 // FULL SCREEN MODE
		function requestFullscreen(element) {
			if (element.requestFullscreen) {
			  element.requestFullscreen();
			} else if (element.mozRequestFullscreen) {
			  element.mozRequestFullscreen();
			} else if (element.mozRequestFullScreen) {
			  element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
			  element.webkitRequestFullscreen();
			}
			// .. and do nothing if the method is not supported
		};
		
		
		window.addEventListener("load",init);
	}());
		
	</script>
</head>
<body>
	<canvas id="canvas" width="1200" height="800"></canvas>
	<div id="controls">
		<audio controls loop></audio>
		<br>
		<p>Volume&emsp;&emsp;</p>
		<input type="range" min="0" max = "100" value = "5" id="volumeSlider"/>	
		<p id="volumeCounter">&emsp;&emsp;5%</p>		
		<br>
		<label>Track: 
			<select id="trackSelect" >
				<option value="media/Great Fairy's Fountain.mp3" selected>Great Fairy's Fountain</option>
				<option value="media/Final Hours.mp3">Final Hours</option>
				<option value="media/Goodbye To A World.mp3">Goodbye to a World</option>
			</select>
		</label>
		<button id="fsButton">Go Full Screen</button><br>
		<br>
		<label>Data Type: 
			<select id="dataTypeSelect">
				<option value="freq" selected>Frequency</option>
				<option value="wave">Waveform</option>
			</select>
		</label>
		<br>
		<input type="range" min="0" max = "10" value = "3" id="trailAmountSlider"/>	
		<p id="trailAmountCounter">Wave Trail Amount: 3</p>
		<br>	
		<input type="range" min="1" max = "10" value = "4" step="1" id="trailBlurSlider"/>	
		<p id="trailBlurCounter">Wave Trail Blur Amount: 4</p>
		<br>	
		<input type="range" min="0" max = "100" value = "0" step="1" id="circleModSlider"/>
		<p id="circleModText">Max Circle Radius Modifier: +0</p>
		<br>
		<input type="range" min="5" max = "500" value = "200" step="1" id="waveMaxSlider"/>
		<p id="waveMaxText">Wave Max Height: 200</p>
		<br>
		<input type="range" min="0" max = "100" value = "4" step="1" id="barMinSlider"/>
		<p id="barMinText">Bar Min Height: 4</p>
		<br>
		<input type="range" min="5" max = "500" value = "70" step="1" id="barMaxSlider"/>		
		<p id="barMaxText">Bar Max Height: 70</p>
		<br>
		<input type="range" min="0" max = "100" value = "2" step="1" id="curveLowMinSlider"/>		
		<p id="curveLowMinText">Low Freq Curve Min Height: 2</p>
		<br>
		<input type="range" min="5" max = "2000" value = "1000" step="1" id="curveLowMaxSlider"/>		
		<p id="curveLowMaxText">Low Freq Curve Max Height: 1000</p>
		<br>
		<input type="range" min="0" max = "100" value = "2" step="1" id="curveHighMinSlider"/>		
		<p id="curveHighMinText">High Freq Curve Min Height: 2</p>
		<br>
		<input type="range" min="5" max = "1000" value = "400" step="1" id="curveHighMaxSlider"/>		
		<p id="curveHighMaxText">High Freq Curve Max Height: 400</p>
		<br>
		<br><br>
		<input type="range" min="0" max = "1" value = "0" step="0.1" id="delayAmountSlider"/>
		<p id="delayAmountCounter">Delay: 0s</p>
		<br>
		<input type="range" min="-30" max = "30" value = "0" step="1" id="bassFilterSlider"/>
		<p id="bassFilterCounter">Bass Boost: 0</p>
		<br>
		<input type="range" min="-30" max = "30" value = "0" step="1" id="trebleFilterSlider"/>
		<p id="trebleFilterCounter">Treble Boost: 0</p>
		<br>
		<br><br>
		<input type="range" min="0" max = "200" value = "0" id="brightnessSlider"/>		
		<p id="brightnessCounter">Brightness: 0</p>
		<br>
		<label>Background Color: 
			<select id="backgroundSelect">
				<option value="black" selected>Black</option>
				<option value="grey">Grey</option>
				<option value="white">White</option>
				<option value="red">Red</option>
				<option value="green">Green</option>			
				<option value="blue">Blue</option>			
			</select>
		</label>
		<br>
		<input type = "checkbox" id="tint">Tint
		<select id="tintSelect">
			<option value="red" selected>Red</option>
			<option value="green">Green</option>
			<option value="blue">Blue</option>
			<option value="purple">Purple</option>
			<option value="yellow">Yellow</option>			
		</select>
		<br>		
		<input type = "checkbox" id="invert">Invert
		<input type = "checkbox" id="noise">Noise
		<input type = "checkbox" id="distort">Distort (laggy)
	</div>
</body>
</html>
